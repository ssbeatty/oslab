### 实验目的
- 掌握 Linux 下的多进程编程技术；
- 通过对进程运行轨迹的跟踪来形象化进程的概念；
- 在进程运行轨迹跟踪的基础上进行相应的数据统计，从而能对进程调度算法进行实际的量化评价，更进一步加深对调度和调度算法的理解，获得能在实际操作系统上对调度算法进行实验数据对比的直接经验。

### 实验内容
- 基于模板 process.c 编写多进程的样本程序，实现如下功能： + 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 30 秒； + 父进程向标准输出打印所有子进程的 id，并在所有子进程都退出后才退出；
- 在 Linux0.11 上实现进程运行轨迹的跟踪。 + 基本任务是在内核中维护一个日志文件 /var/process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 log 文件中。
- 在修改过的 0.11 上运行样本程序，通过分析 log 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 python 脚本程序—— stat_log.py（在 /home/teacher/ 目录下） ——进行统计。
- 修改 0.11 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。

### 资料
```c
#include <unistd.h>
#include <sys/types>

pid_t getpid(void);

pid_t fork(void);

// wait_stat记录子进程的返回状态，包括返回值，是否是由于signal造成的终止（停止）等等各种状态。
pid_t wait(int * wait_stat);
```

> process.log 格式

```text
pid    X    time
```
X 可以是 N、J、R、W 和 E 中的任意一个，分别表示进程新建(N)、进入就绪态(J)、进入运行态(R)、进入阻塞态(W) 和退出(E)；


### 实验过程
1. 编写process.c多进程程序，详见`process.c`

2. 增加log文件`/var/process.log`
> init/main.c
```c
//……
move_to_user_mode();

// 这里把init()里面的创建0,1,2句柄在这里创建
/***************添加开始***************/
setup((void *) &drive_info);

// 建立文件描述符0和/dev/tty0的关联
(void) open("/dev/tty0",O_RDWR,0);

//文件描述符1也和/dev/tty0关联
(void) dup(0);

// 文件描述符2也和/dev/tty0关联
(void) dup(0);

(void) open("/var/process.log",O_CREAT|O_TRUNC|O_WRONLY,0666);

/***************添加结束***************/

if (!fork()) {        /* we count on this going ok */
    init();
}
//……
```

3. 实现fprintk方法，这个直接看实验楼里面的加到`printk.c`

4. jiffies
jiffies 在 kernel/sched.c 文件中定义为一个全局变量：
它记录了从开机到当前时间的时钟中断发生次数。在 kernel/sched.c 文件中的 sched_init() 函数中，时钟中断处理函数被设置为：
```c
long volatile jiffies=0;

set_intr_gate(0x20,&timer_interrupt);
```
这说明 jiffies 表示从开机时到现在发生的时钟中断次数，这个数也被称为 “滴答数”。

5. 寻找切换点，分别看`fork.c`，`exit.c`，`sched.c`。

6. 打印信息，使用`./stat_log.py process.log 0 1 2 -g`，输出如下：
```text
(Unit: tick)
Process   Turnaround   Waiting   CPU Burst   I/O Burst
     0           75        67           8           0
     1         2518         0           1        2517
     2           25         4          21           0
     3         3003         0           4        2999
     4         5317         6          51        5260
     5            3         0           3           0
Average:     1823.50     12.83
Throughout: 0.11/s
-----===< COOL GRAPHIC OF SCHEDULER >===-----

            [Symbol]   [Meaning]
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~
             number   PID or tick
              "-"     New or Exit
              "#"       Running
              "|"        Ready
              ":"       Waiting
                    / Running with
              "+" -|     Ready
                    \and/or Waiting

-----===< !!!!!!!!!!!!!!!!!!!!!!!!! >===-----

  40 -0
  41 #0
  42 #
  43 #
  44 #
  45 #
  46 #
  47 #
  48 |0  -1
  49 |   :1  -2
  50 |   :   #2
  51 |   :   #
  52 |   :   #
  53 |   :   #
  54 |   :   #
  55 |   :   #
  56 |   :   #
  57 |   :   #
  58 |   :   #
  59 |   :   #
  60 |   :   #
  61 |   :   #
  62 |   :   #
  63 |   :   #
  64 |   :   |2  -3
  65 |   :   |   #3
  66 |   :   |   #
  67 |   :   |   #
…………
```

7. 修改时间片

> include/linux/sched.h

```c
#define INIT_TASK \
    { 0,15,15,
// 上述三个值分别对应 state、counter 和 priority;
```

修改priority就是修改初始时间片。

### 问题

> 单进程编程和多进程编程的区别？

1. 执行方式：单进程编程是一个进程从上到下顺序进行；多进程编程可以通过并发执行，即多个进程之间交替执行，如某一个进程正在I/O输入输出而不占用CPU时，可以让CPU去执行另外一个进程，这需要采取某种调度算法。

2. 数据是否同步：单进程的数据是同步的，因为单进程只有一个进程，在进程中改变数据的话，是会影响这个进程的；多进程的数据是异步的，因为子进程数据是父进程数据在内存另一个位置的拷贝，因此改变其中一个进程的数据，是不会影响到另一个进程的。

3. CPU利用率：单进程编程的CPU利用率低，因为单进程在等待I/O时，CPU是空闲的；多进程编程的CPU利用率高，因为当某一进程等待I/O时，CPU会去执行另一个进程，因此CPU的利用率高。

> 时间片的大小

1. 当时间片非常小的时候，平均周转时间和等待时间应该是非常大的，因为进程切换地太频繁，浪费大量的时间再进程切换上。
2. 当时间片适宜的时候，平均周转时间和等待时间是最低的，因为既不会浪费大量时间在进程切换上，又不会让只需占用一小会CPU的进程等待太多的时间（也就是说对于只占用很短时间CPU的进程而言，它不会等待太多的时间）。
3. 当时间片足够大的时候，就变成了先进先出的调度算法，虽然不会浪费时间在进程切换上，但是用户交互性差，平均周转时间和等待时间可能又会变大（当然这取决于各个进程占用CPU时间长短的差异性以及各个进程的执行次序），比如第一个进程占用CPU一小时，而后7个进程只需占用CPU一分钟，那么后面7个进程每个进程都要等第一个进程一小时，等待时间和周转时间自然变大；如果时间片适宜，让第一个进程占用1分钟CPU后就切换到第二个进程，那么后面7个进程几乎不需要等待多久就可以执行完毕，会大大减小周转时间和等待时间。